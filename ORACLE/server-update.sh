#!/usr/bin/env bash
# ======================================================================
# üîÑ Ubuntu 24.04 ‚Äì Script de MANUTEN√á√ÉO/ATUALIZA√á√ÉO peri√≥dica
# - Pode rodar via cron/systemd timer com seguran√ßa (idempotente)
# - Atualiza pacotes (APT/Snap), Docker, stacks Docker Compose opcionais
# - Limpeza opcional (journal, imagens/volumes antigos), checa reboot
# - Log detalhado e lock para evitar execu√ß√£o concorrente
# ======================================================================

set -euo pipefail
IFS=$'\n\t'

# ----------------------------------------------------------------------
# üß© PERSONALIZA√á√ÉO ‚Äî edite conforme sua necessidade
# ----------------------------------------------------------------------

# APT
APT_FULL_UPGRADE=true             # full-upgrade com autoremove
APT_CLEAN_CACHE=true              # limpa cache do apt ap√≥s upgrade
APT_STOP_TIMERS=true              # pausa apt-daily* para evitar locks

# SNAP
SNAP_REFRESH=true                 # atualiza pacotes snap (se snapd instalado)

# DOCKER
DOCKER_ENABLE=true                # executa tarefas Docker se bin√°rio existir
DOCKER_PRUNE_LEVEL="dangling"     # none | dangling | safe | aggressive
DOCKER_PRUNE_SAFE_UNTIL="168h"    # usado no modo "safe": n√£o usados h√° >= 168h (7 dias)
DOCKER_RESTART_IF_INACTIVE=true   # garante docker ativo ap√≥s upgrades
WATCHTOWER_REFRESH=true           # puxa/garante watchtower (se existir)
# Atualiza√ß√£o de stacks Docker Compose (passe diret√≥rios com docker-compose.yml / compose.yaml)
COMPOSE_STACKS=(                  # ex.: "/opt/stacks/prod" "/srv/blog"
)

# SISTEMA
APPLY_SYSCTL=true                 # reaplica sysctl --system (sincroniza ajustes)
RELOAD_SSHD=true                  # valida e recarrega sshd (sem desconectar sess√µes ativas)
RELOAD_FAIL2BAN=true              # reload no fail2ban se instalado
RELOAD_UFW=false                  # ufw reload (mant√©m regras), desative se usa regras muito din√¢micas

# LIMPEZAS
JOURNALCTL_VACUUM_TIME="14d"      # "" para desativar. Ex.: "7d" | "2G" | "1month"
VACUUM_TMP=true                   # limpa /tmp e /var/tmp (apenas arquivos > 7 dias)
PRUNE_OLD_SNAPS=true              # remove revis√µes antigas de snaps

# REBOOT
REBOOT_MODE="if_required"         # never | if_required | always
ANNOUNCE_REBOOT_SECONDS=60        # se reboot, anuncia via wall com anteced√™ncia

# OBSERVABILIDADE (opcional)
HEALTHCHECKS_START_URL=""         # URL para ping de start (healthchecks.io)
HEALTHCHECKS_SUCCESS_URL=""       # URL para ping de sucesso
HEALTHCHECKS_FAIL_URL=""          # URL para ping de falha

# LOG/LOCK
LOG_FILE="/var/log/maintenance_update.log"
LOCK_FILE="/var/run/maintenance_update.lock"
RETRY_COUNT=3
RETRY_DELAY=5

# ----------------------------------------------------------------------
# üîß Fun√ß√µes auxiliares
# ----------------------------------------------------------------------
log() { printf "%s %s\n" "[$(date +'%F %T')]" "$*" | tee -a "$LOG_FILE"; }
have() { command -v "$1" >/dev/null 2>&1; }
err_handler() {
  log "‚ùå Erro na linha $1: comando '${BASH_COMMAND}'"
  [[ -n "$HEALTHCHECKS_FAIL_URL" ]] && curl -fsS "$HEALTHCHECKS_FAIL_URL" >/dev/null 2>&1 || true
  rm -f "$LOCK_FILE" || true
  exit 1
}
trap 'err_handler $LINENO' ERR

is_true() { case "${1,,}" in true|1|yes|on) return 0 ;; *) return 1 ;; esac; }

run_apt() {
  for i in $(seq 1 "$RETRY_COUNT"); do
    if DEBIAN_FRONTEND=noninteractive apt-get -y "$@"; then return 0; fi
    log "‚ö†Ô∏è apt-get $* falhou (tentativa $i/$RETRY_COUNT), aguardando‚Ä¶"
    sleep "$RETRY_DELAY"
  done
  log "‚ùå apt-get $* falhou ap√≥s $RETRY_COUNT tentativas."; return 1
}

curl_ping() { [[ -n "$1" ]] && curl -fsS "$1" >/dev/null 2>&1 || true; }

bytes_to_human() {
  local b=$1; local d='' s=0 S=(B KB MB GB TB PB EB ZB YB)
  while ((b>1024 && s<${#S[@]}-1)); do d="$(printf ".%02d" $(( (b%1024*100)/1024 )))"; b=$((b/1024)); s=$((s+1)); done
  printf "%s%s %s" "$b" "$d" "${S[$s]}"
}

disk_free_root() {
  df -B1 / | awk 'NR==2{print $4}'
}

pause_apt_timers() {
  systemctl stop apt-daily.service apt-daily.timer apt-daily-upgrade.service apt-daily-upgrade.timer || true
  systemctl kill --kill-who=all apt-daily.service apt-daily-upgrade.service || true
  while pgrep -x apt >/dev/null || pgrep -x apt-get >/dev/null || pgrep -x unattended-upgrade >/dev/null; do sleep 1; done
}

# ----------------------------------------------------------------------
# 0) Pr√©-checagens / lock / logs
# ----------------------------------------------------------------------
[[ $EUID -eq 0 ]] || { echo "‚ùå Rode como root (sudo)."; exit 1; }
mkdir -p "$(dirname "$LOG_FILE")"; touch "$LOG_FILE"
if [[ -e "$LOCK_FILE" ]]; then
  log "‚ö†Ô∏è J√° existe lock: $LOCK_FILE ‚Äî abortando para evitar concorr√™ncia."
  exit 0
fi
echo $$ > "$LOCK_FILE"

curl_ping "$HEALTHCHECKS_START_URL"
log "üîÅ Iniciando manuten√ß√£o peri√≥dica‚Ä¶"
log "üì¶ Free root antes: $(bytes_to_human "$(disk_free_root)")"

# ----------------------------------------------------------------------
# 1) APT: atualizar sistema
# ----------------------------------------------------------------------
if is_true "$APT_STOP_TIMERS"; then
  log "‚è±Ô∏è Pausando timers apt para evitar locks‚Ä¶"
  pause_apt_timers
fi

log "üóÇÔ∏è Atualizando √≠ndices APT‚Ä¶"
run_apt update

if is_true "$APT_FULL_UPGRADE"; then
  log "‚¨ÜÔ∏è Executando full-upgrade‚Ä¶"
  run_apt full-upgrade
  is_true "$APT_CLEAN_CACHE" && { run_apt autoremove; apt-get clean || true; }
else
  log "‚¨ÜÔ∏è Executando upgrade simples‚Ä¶"
  run_apt upgrade
fi

# ----------------------------------------------------------------------
# 2) Snap refresh (opcional)
# ----------------------------------------------------------------------
if is_true "$SNAP_REFRESH" && have snap; then
  log "üì¶ Atualizando snaps‚Ä¶"
  snap refresh || log "‚ö†Ô∏è snap refresh retornou c√≥digo de erro (prosseguindo)."
  if is_true "$PRUNE_OLD_SNAPS"; then
    log "üßπ Removendo revis√µes antigas de snaps‚Ä¶"
    set +e
    snap list --all | awk '/disabled/{print $1, $3}' | while read -r name rev; do snap remove "$name" --revision="$rev"; done
    set -e
  fi
fi

# ----------------------------------------------------------------------
# 3) Docker: engine, prune, stacks compose
# ----------------------------------------------------------------------
if is_true "$DOCKER_ENABLE" && have docker; then
  log "üê≥ Verificando Docker engine‚Ä¶"
  systemctl is-active --quiet docker || {
    is_true "$DOCKER_RESTART_IF_INACTIVE" && { log "üîÅ Reiniciando Docker‚Ä¶"; systemctl restart docker || true; }
  }

  # Docker prune conforme pol√≠tica
  case "$DOCKER_PRUNE_LEVEL" in
    none)
      log "üßπ Docker prune: desativado."
      ;;
    dangling)
      log "üßπ Docker prune (dangling)‚Ä¶"
      docker system prune -f || true
      ;;
    safe)
      log "üßπ Docker prune SAFE (n√£o usados h√° >= ${DOCKER_PRUNE_SAFE_UNTIL})‚Ä¶"
      docker image prune -af --filter "until=${DOCKER_PRUNE_SAFE_UNTIL}" || true
      docker container prune -f --filter "until=${DOCKER_PRUNE_SAFE_UNTIL}" || true
      ;;
    aggressive)
      log "üßπ Docker prune AGGRESSIVE (inclui volumes!)‚Ä¶"
      docker system prune -af --volumes || true
      ;;
    *)
      log "‚ö†Ô∏è N√≠vel de prune desconhecido: $DOCKER_PRUNE_LEVEL"
      ;;
  esac

  # Watchtower opcional (pull + restart)
  if is_true "$WATCHTOWER_REFRESH"; then
    if docker ps --format '{{.Names}}' | grep -qx watchtower; then
      log "üì° Atualizando imagem do Watchtower‚Ä¶"
      docker pull containrrr/watchtower:latest || true
      docker restart watchtower || true
    fi
  fi

  # Atualizar stacks docker compose
  if ((${#COMPOSE_STACKS[@]})); then
    if docker compose version >/dev/null 2>&1; then
      for stack_dir in "${COMPOSE_STACKS[@]}"; do
        [[ -d "$stack_dir" ]] || { log "‚ö†Ô∏è Stack n√£o encontrado: $stack_dir"; continue; }
        compose_file=""
        for f in docker-compose.yml docker-compose.yaml compose.yml compose.yaml; do
          [[ -f "$stack_dir/$f" ]] && { compose_file="$stack_dir/$f"; break; }
        done
        if [[ -z "$compose_file" ]]; then
          log "‚ö†Ô∏è Nenhum compose*.yml encontrado em $stack_dir"
          continue
        fi
        log "üì¶ Atualizando stack: $stack_dir"
        ( cd "$stack_dir"
          docker compose pull
          docker compose up -d --remove-orphans
        ) || log "‚ö†Ô∏è Falha ao atualizar stack em $stack_dir (prosseguindo)."
      done
    else
      log "‚ö†Ô∏è 'docker compose' n√£o dispon√≠vel; pulando atualiza√ß√£o de stacks."
    fi
  fi
else
  log "‚ÑπÔ∏è Docker desabilitado por config ou n√£o instalado."
fi

# ----------------------------------------------------------------------
# 4) Servi√ßos e seguran√ßa
# ----------------------------------------------------------------------
if is_true "$RELOAD_SSHD" && have sshd && systemctl is-enabled --quiet ssh; then
  log "üîê Validando configura√ß√£o do sshd‚Ä¶"
  if sshd -t 2>>"$LOG_FILE"; then
    systemctl reload ssh || true
  else
    log "‚ö†Ô∏è sshd -t encontrou problemas; N√ÉO recarregado (ver log)."
  fi
fi

if is_true "$RELOAD_FAIL2BAN" && have fail2ban-client && systemctl is-enabled --quiet fail2ban; then
  log "üö® Recarregando Fail2Ban‚Ä¶"
  fail2ban-client reload || log "‚ö†Ô∏è fail2ban reload retornou erro (prosseguindo)."
fi

if is_true "$RELOAD_UFW" && have ufw; then
  log "üî• Recarregando UFW‚Ä¶"
  ufw reload || log "‚ö†Ô∏è ufw reload retornou erro (prosseguindo)."
fi

if is_true "$APPLY_SYSCTL"; then
  log "‚öôÔ∏è Aplicando sysctl --system‚Ä¶"
  sysctl --system >/dev/null || log "‚ö†Ô∏è sysctl --system retornou erro (prosseguindo)."
fi

# ----------------------------------------------------------------------
# 5) Limpezas diversas
# ----------------------------------------------------------------------
if [[ -n "$JOURNALCTL_VACUUM_TIME" ]] && have journalctl; then
  log "üßΩ Compactando logs do journal (vacuum: $JOURNALCTL_VACUUM_TIME)‚Ä¶"
  journalctl --vacuum-time="$JOURNALCTL_VACUUM_TIME" || true
fi

if is_true "$VACUUM_TMP"; then
  log "üßπ Limpando arquivos antigos em /tmp e /var/tmp (>7d)‚Ä¶"
  find /tmp -xdev -type f -mtime +7 -print0 2>/dev/null | xargs -0r rm -f || true
  find /var/tmp -xdev -type f -mtime +7 -print0 2>/dev/null | xargs -0r rm -f || true
fi

# ----------------------------------------------------------------------
# 6) Reboot (conforme pol√≠tica)
# ----------------------------------------------------------------------
need_reboot=false
[[ -f /var/run/reboot-required ]] && need_reboot=true

case "$REBOOT_MODE" in
  always)
    log "üîÅ REBOOT: agendado (modo = always)."
    wall "‚ö†Ô∏è Servidor ser√° reiniciado em ${ANNOUNCE_REBOOT_SECONDS}s para concluir manuten√ß√£o." || true
    sleep "$ANNOUNCE_REBOOT_SECONDS"
    curl_ping "$HEALTHCHECKS_SUCCESS_URL"
    rm -f "$LOCK_FILE" || true
    reboot
    ;;
  if_required)
    if $need_reboot; then
      log "üîÅ REBOOT: necess√°rio (kernel/libc atualizados)."
      wall "‚ö†Ô∏è Servidor ser√° reiniciado em ${ANNOUNCE_REBOOT_SECONDS}s (atualiza√ß√µes cr√≠ticas aplicadas)." || true
      sleep "$ANNOUNCE_REBOOT_SECONDS"
      curl_ping "$HEALTHCHECKS_SUCCESS_URL"
      rm -f "$LOCK_FILE" || true
      reboot
    else
      log "‚úÖ REBOOT: n√£o necess√°rio."
    fi
    ;;
  never)
    log "üö´ REBOOT: desativado por configura√ß√£o (h√° necessidade? $need_reboot)."
    ;;
  *)
    log "‚ö†Ô∏è REBOOT_MODE inv√°lido: $REBOOT_MODE (usando if_required)."
    if $need_reboot; then
      wall "‚ö†Ô∏è Servidor ser√° reiniciado em ${ANNOUNCE_REBOOT_SECONDS}s (atualiza√ß√µes cr√≠ticas aplicadas)." || true
      sleep "$ANNOUNCE_REBOOT_SECONDS"
      curl_ping "$HEALTHCHECKS_SUCCESS_URL"
      rm -f "$LOCK_FILE" || true
      reboot
    fi
    ;;
esac

# ----------------------------------------------------------------------
# Fim
# ----------------------------------------------------------------------
log "üì¶ Free root depois: $(bytes_to_human "$(disk_free_root)")"
log "‚úÖ Manuten√ß√£o conclu√≠da sem reboot."
curl_ping "$HEALTHCHECKS_SUCCESS_URL"
rm -f "$LOCK_FILE" || true

# ======================================================================
# Sugest√£o de agendamento com systemd timer (salvar como /usr/local/sbin/maintenance.sh)
# chmod +x /usr/local/sbin/maintenance.sh
# cat >/etc/systemd/system/maintenance.service <<'UNIT'
# [Unit]
# Description=Maintenance & Update
# After=network-online.target
#
# [Service]
# Type=oneshot
# ExecStart=/usr/local/sbin/maintenance.sh
# Nice=10
# IOSchedulingClass=best-effort
# IOSchedulingPriority=4
#
# [Install]
# WantedBy=multi-user.target
# UNIT
#
# cat >/etc/systemd/system/maintenance.timer <<'UNIT'
# [Unit]
# Description=Run maintenance weekly
#
# [Timer]
# OnCalendar=Sun *-*-* 03:30:00
# Persistent=true
#
# [Install]
# WantedBy=timers.target
# UNIT
#
# systemctl daemon-reload
# systemctl enable --now maintenance.timer
# ======================================================================
